#  Bep Marketplace ELE
#  Copyright (c) 2016-2022 Kolibri Solutions
#  License: See LICENSE file or https://github.com/KolibriSolutions/BepMarketplace/blob/master/LICENSE
#
from django.conf import settings
from django.contrib.auth.models import User
from django.core.cache import cache
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

from general_model import clean_text
from timeline.models import TimeSlot
from timeline.utils import get_timeslot_id


class Track(models.Model):
    """
    Stores the tracks for EE. Like SSS, CW, C&C en Automotive.
    Head is the professor that is the head of the track.
    """
    Name = models.CharField(max_length=255, unique=True)
    ShortName = models.CharField(max_length=10, unique=True)
    Head = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name="tracks")

    def __str__(self):
        return str(self.ShortName)

    class Meta:
        ordering = ["Name"]

    def clean(self):
        self.Name = clean_text(self.Name)
        self.ShortName = clean_text(self.ShortName)


class Broadcast(models.Model):
    """
    A message that is shown in the sidebar. Can be for everyone or only for one user (private).
    """
    Message = models.CharField(max_length=512)
    DateBegin = models.DateField(blank=True, null=True)
    DateEnd = models.DateField(blank=True, null=True)
    Private = models.ForeignKey(User, on_delete=models.DO_NOTHING, null=True, blank=True,
                                related_name="private_broadcasts")

    def __str__(self):
        return self.Message

    def clean(self):
        self.Message = clean_text(self.Message)


class FeedbackReport(models.Model):
    """
    Feedback report as generated by a user. Viewable for superusers.
    """
    StatusChoices = (
        (1, "Open"),
        (2, "Confirmed"),
        (3, "Closed"),
    )

    Reporter = models.ForeignKey(User, on_delete=models.CASCADE, related_name='feedbackreports')
    Url = models.CharField(max_length=255)
    Feedback = models.CharField(max_length=1024)
    Timestamp = models.DateTimeField(auto_now_add=True)
    Status = models.IntegerField(choices=StatusChoices, validators=[MinValueValidator(1), MaxValueValidator(3)])

    def __str__(self):
        return "Report by " + self.Reporter.username + " Status: " + self.get_Status_display()

    def clean(self):
        self.Feedback = clean_text(self.Feedback)


class UserMeta(models.Model):
    """
    Meta for a user. Augmented user model.
    Overruled is true if 'EnrolledBEP' and 'EnrolledExt' 'should not be automatically updated on Canvaslogin.
    """
    User = models.OneToOneField(User, on_delete=models.CASCADE)
    SuppressStatusMails = models.BooleanField(default=False, help_text='set to True to receive less emails from the system.')
    Department = models.CharField(max_length=512, null=True, blank=True)
    Study = models.CharField(max_length=512, null=True, blank=True)
    Cohort = models.IntegerField(null=True, blank=True, help_text='Start year of students study')
    Studentnumber = models.CharField(max_length=20, null=True, blank=True)
    Culture = models.CharField(max_length=64, null=True, blank=True)
    Initials = models.CharField(max_length=64, null=True, blank=True)
    Fullname = models.CharField(max_length=64, null=True, blank=True)
    ECTS = models.IntegerField(validators=[MinValueValidator(0), MaxValueValidator(300)], default=0)
    EnrolledBEP = models.BooleanField(default=False, help_text='Whether student user is enrolled in BEP course.')
    EnrolledExt = models.BooleanField(default=False, help_text='Whether student user is enrolled in BEP-extension course.')
    Overruled = models.BooleanField(default=False, help_text='Set to True to not update certain fields during login of user.')
    TimeSlot = models.ManyToManyField(TimeSlot, default=get_timeslot_id, related_name='users', blank=True, help_text='Time slots where the user (student) is active in.')
    Affiliation = models.CharField(max_length=128, null=True, blank=True)

    def __str__(self):
        return str(self.User)

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        cache.delete('user_nice_fullname_{}'.format(self.id))

    def get_nice_name(self):
        """
        Get a users full name with preposition

        :return:
        """
        return self.get_nice_fullname()

    def get_nice_fullname(self):
        """
        Get fullname with fallback to normal name

        :return:
        """
        name = cache.get('user_nice_fullname_{}'.format(self.id))
        if name is None:
            if self.Fullname and len(self.Fullname) > 2:
                name = self.Fullname
            else:
                if self.User.first_name and self.User.last_name:
                    name = f'{self.User.last_name}, {self.User.first_name}'.strip()
                else:
                    try:
                        name = self.User.email.split('@')[0]
                    except:
                        name = self.User.username
            cache.set('user_nice_fullname_{}'.format(self.id), name, settings.STATIC_OBJECT_CACHE_DURATION)
        return name


class Term(models.Model):
    Text = models.TextField()

    def __str__(self):
        return "Term {}".format(self.id)


class UserAcceptedTerms(models.Model):
    User = models.OneToOneField(User, on_delete=models.CASCADE, related_name='termsaccepted')
    Stamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return str(self.User)
